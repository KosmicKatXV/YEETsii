import java_cup.runtime.*;
import java.util.*; 

action code {:
:};

terminal        String  IDENT,NUMERO,TEXTO;
terminal        Integer INT,CHAR,FLOAT;
terminal                ALL, CLL, AP, CP, PYC, ASIG, MAS, MENOS, POR, DIV, COMA, PP, AB, CB;
terminal                LEQ, LNEQ, LMA, LMAQ, LME, LMEQ, LNE, LAND, LOR;
terminal                IF, ELSE, WHILE, DO, FOR, PRINT;
terminal                SET,ADD,DEL;
           
non terminal                    sent,lsent,else;
non terminal    Integer         type;
non terminal    String          expr,ident;
non terminal    String[]        aexpr;
non terminal    List<String>    array;
non terminal    Tag             cond;

precedence left CP;
precedence left LOR;
precedence left LAND;
precedence left LEQ, LNEQ, LMA, LMAQ, LME, LMEQ;
precedence left MAS, MENOS;
precedence left POR, DIV;
precedence left SET;
precedence nonassoc IF;
precedence nonassoc ELSE;

lsent   ::=   sent lsent
            | sent
            ;
sent    ::=   expr PYC
            | IF AP cond:c CP {:
                comp.labelIt(c.getV());
                comp.addTag(c);
            :} sent else
            | FOR AP IDENT:id PP IDENT:a CP {:
                comp.chk(id,a,false);
                comp.asig(id,comp.ite_start(a));
            :} sent {: comp.ite_end(); :}
            | WHILE AP {: comp.while_start(); :} cond:c CP {: comp.labelIt(c.getV()); :} sent {: comp.while_end(c); :}
            | DO {: comp.do_start(); :} sent WHILE AP cond:c CP PYC{:
                comp.do_end(c);
            :}
            | FOR AP sent {: comp.for_start(); :} cond:c PYC {: comp.for_mid1(); :} expr CP {: comp.for_mid2(c); :} sent {: comp.for_end(c); :}
            | PRINT AP expr:e CP PYC {: comp.print(e); :}
            | ALL lsent CLL
            ;
else    ::=   ELSE {: comp.if_else(); :} sent {: comp.if_end(true); :}
            | {: comp.if_end(false); :}
            ;
expr    ::=   expr:e1 MAS expr:e2   {: RESULT = comp.op(e1,e2,0); :}
            | expr:e1 MENOS expr:e2 {: RESULT = comp.op(e1,e2,1); :}
            | expr:e1 POR expr:e2   {: RESULT = comp.op(e1,e2,2); :}
            | expr:e1 DIV expr:e2   {: RESULT = comp.op(e1,e2,3); :}
            | MENOS expr:e          {: RESULT = comp.op("",e,1); :}
            | AP expr:e CP          {: RESULT = e; :}
            | type:n IDENT:id       {: comp.set(id,n); :}
            | type:t aexpr:id       {: comp.set(id[0],t+3); comp.setLen(id[0],id[1]); :}
            | ident:id              {: RESULT = id; :}
            | IDENT:id ASIG expr:e  {: RESULT = comp.asig(id,e); :}
            | aexpr:id ASIG expr:e  {: RESULT = comp.asig(id[2],e); :}
            | IDENT:id ASIG ALL array:a CLL {: RESULT = comp.asig(id,a.toArray(new String[a.size()])); :}
            | IDENT:id ADD  ALL array:a CLL {: RESULT = comp.add(id,a.toArray(new String[a.size()])); :}
            | IDENT:id ADD  expr:e {: RESULT = comp.add(id,e); :}
            | IDENT:id DEL  ALL array:a CLL {: RESULT = comp.del(id,a.toArray(new String[a.size()])); :}
            | IDENT:id DEL  expr:e {: RESULT = comp.del(id,e); :}
            | NUMERO:n {: RESULT = n; :}
            | TEXTO:t  {: RESULT = String.valueOf(t.charAt(0)); :}
            ;
ident   ::=   aexpr:id {: RESULT = comp.asig(comp.getVar(),id[2]); :}
            | IDENT:id {: RESULT = id; :}
            ;
aexpr   ::=   IDENT:id AB NUMERO:n CB {: RESULT = new String[]{id,n,id+"["+n+"]"}; :}
            ;
cond    ::=   expr:e1 LEQ  expr:e2  {: RESULT = comp.if_start(e1,e2,0); :}
            | expr:e1 LNEQ expr:e2  {: RESULT = comp.if_start(e1,e2,1); :}
            | expr:e1 LMA  expr:e2  {: RESULT = comp.if_start(e1,e2,2); :}
            | expr:e1 LMAQ expr:e2  {: RESULT = comp.if_start(e1,e2,3); :}
            | expr:e1 LME  expr:e2  {: RESULT = comp.if_start(e1,e2,4); :}
            | expr:e1 LMEQ expr:e2  {: RESULT = comp.if_start(e1,e2,5); :}
            | cond:c1 LAND          {: comp.labelIt(c1.getV()); :} cond:c2 {: RESULT = comp.lop(c1,c2,false); :}
            | cond:c1 LOR           {: comp.labelIt(c1.getF()); :} cond:c2 {: RESULT = comp.lop(c1,c2,true); :}
            | AP cond:c CP          {: RESULT = c; :}
            | LNE cond:c            {: RESULT = c.invert(); :}
            ;
type    ::=   INT:n         {: RESULT = n; :}
            | CHAR:n        {: RESULT = n; :}
            | FLOAT:n       {: RESULT = n; :}
            | SET type:n    {: RESULT = n+3; :}
            ;
array   ::=   expr:e COMA array:a {: a.add(e); RESULT = a; :}
            | expr:e {:
                List<String> l = new ArrayList<String>();
                l.add(e);
                RESULT = l;
            :}
            ;